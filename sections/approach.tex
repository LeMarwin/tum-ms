\chapter{Approach}\label{chapter:approach}
\section{Approach}
As stated in \ref{sec:approach}, the goal chosen by the project is to remove the ordering service altogether.

However, doing so is impractical. The ordering system is not only used to issue blocks but also serves as an administrative point for the network. To remove the ordering service completely means losing the system responsible for creating channels, uploading chaincodes to the peers and issuing configuration blocks.

The overall approach is to make as little changes to the code as possible.
Thus it was decided to keep the ordering system intact for administrative purposes, but to remove it from transaction flow.

\section{Consequences of a lack of ordering service}
\label{sec:app-noorder}

A natural way to remove the ordering service is to give peers a way of establishing consensus regarding the order of transactions. However, implementing a PBFT or PoW consensus for peers is well beyond the scope of the project.

Without a way of establishing consensus, there is no way for peers to agree on the order of transactions. We circumvent this obstacle by limiting the domain of possible world states and transactions.

In the project, the world state is represented by a CRDT and all transactions must be conflict-free. This will allow peers to eventually agree on the world state while receiving transactions in a different order. Provided, of course, that all peers have the same set of transactions, i.e. they receive all transactions submitted to the network.

Eliminating the ordering of transactions seems counterintuitive in a blockchain setting. The purpose of blockchain is to establish a canonical order of transactions and to make sure it is the same all nodes of the network.

At first, it seemed that there is no point in keeping the blockchain at all. In which case the system devolves into a CRDT-based replicated database.

After further considerations, it was decided to keep the blockchain's ledger as a means of keeping track of all the transactions and for auditing purposes. This decision also aligns with the "change as little as possible" approach, chosen by the project.

However, there will be no canonical chain or ledger among peers. The solution is to make each peer keep its own local ledger. The downside of this solution is that peers will not be able to gossip blocks between each other. It becomes the job of the client to ensure that all peers received all transactions from the client, or else they will disagree on the world state.

\section{New transaction flow}
\label{sec:app-flow}

We propose a modified transaction flow. The original one is explained in \ref{sec:flow}.

The new transaction lifecycle is, roughly as follows

\begin{itemize}
  \item Proposal
  \item Broadcast
  \item Commit
\end{itemize}

The Propose phase is exactly the same as the original one.

The client collects proposal responses and creates a transaction envelope as usual.  But instead of sending it to the ordering service, the client broadcasts the transaction envelope to all peers of the network.

A peer receives the envelope and does signature validation as per the original protocol. However, the peer does not perform any MVCC consistency check. Since we assume only conflict-free transactions, there is no point in doing consistency checks. The burden of keeping transactions conflict-free lies on the chaincode creator.

The peer checks signatures and directly commits the transaction to its local ledger. The client receives a receipt containing the height at which the transaction was committed along with the hash of the block.

When the client receives receipts from all the peers it considers the transaction lifecycle completed.

\section{Endorser augmentation}
\label{sec:augm}
Instead of adding an entirely new component to a peer that handles transaction commitment it is better to augment an existing component.

Since the Endorser service is the part of a peer that is exposed to the client as described in \ref{sec:back-peer}, it was decided to use it as the host to the new functionality.

It has to keep track of all blocks coming from the ordering service to commit them to the local ledger. So that they don't go the usual commit route and disrupt the system.

It also has to be notified when its peer is asked to join a new channel so it can create a new ledger.

This is done by connecting the Gossip system with the Endorser system via channels.

We have added two Go channels to the Gossip system:
\begin{itemize}
  \item joinChan
  \item blockChan
\end{itemize}

Since the Gossip system is accessible from any part of the peers code, these channels are also accessible and the Endorser can listen to incoming messages.

The Gossip sends a message with the name of the new Fabric channel to the Endorser through $joinChan$.
When the Endorser receives a message from $joinChan$ it creates a new $BlockProcessor$ for that Fabric channel.

The $BlockProcessor$ handles incoming blocks and transaction envelope, commits them to the ledger, produces receipts and keeps track of the chain. Details about the $BlockProcessors'$ implementation are in a separate segment.

The Gossip system also sends any incoming blocks from the orderer service to the Endorser system via $blockChan$.
The Endorser redirects the incoming blocks to the appropriate $BlockProcessor$ to be committed to the ledger.

We have added a new RPC endpoint to the Endorser service.

\begin{lstlisting}
rpc SendEnvelope(common.Envelope) returns (BlockReceipt) {}
\end{lstlisting}

It receives an envelope, checks signatures, commits the transaction to the appropriate ledger and returns a receipt structure $BlockReceipt$.

\begin{lstlisting}
message BlockReceipt {

  // Id of the peer sending the receipt
  PeerID id = 1;

  // Header of the block with the transaction from the request
  common.BlockHeader header = 2;

  // Response structure with additional information
  Response response = 3;
}

// A response with a representation similar to an HTTP response that can
// be used within another message.
message Response {

   // A status code that should follow the HTTP status codes.
   int32 status = 1;

   // A message associated with the response code.
   string message = 2;

   // A payload that can be used to include metadata with this response.
   bytes payload = 3;
}
\end{lstlisting}

The handler for this endpoint is straightforward. Receive an envelope, send it to the appropriate $BlockProcessor$, wait until the transaction is committed, receive the block header from the $BlockProcessor$ and send back the receipt.

The Endorser communicates with a $BlockProcessor$ via Go channels.
It sends an envelope via $Enqueue$ method of $BlockProcessor$ and receives back a Go channel where the block header will be sent to once the envelope is committed to the ledger. 
